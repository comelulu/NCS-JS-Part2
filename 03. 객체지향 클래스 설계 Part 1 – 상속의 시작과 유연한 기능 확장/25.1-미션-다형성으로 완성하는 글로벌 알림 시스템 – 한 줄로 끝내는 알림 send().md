# ✅ 다형성으로 완성하는 글로벌 알림 시스템 – “한 줄로 끝내는 알림 send()”

---

## 🌱 미션 배경 – 당신은 이제 실전 개발자!

당신은 이제 막 스타트업에 합류한 프론트엔드 개발자입니다.
출근 첫 주, 팀장이 이렇게 말합니다:

> "우리 서비스에서 알림을 다양하게 보내야 하거든?
> 지금은 이메일로만 보내고 있는데,
> 문자도 보내야 하고 앱 푸시도 넣어야 해.
> 그때그때 if, else로 때우지 말고,
> 앞으로 어떤 채널이 생겨도 한 줄로 보낼 수 있게 구조를 짜줄 수 있어?"

기존 알림 코드는 다음과 같습니다:

```js
if (channel === "email") {
  sendEmail(to, message);
} else if (channel === "sms") {
  sendSMS(to, message);
} else if (channel === "push") {
  sendPush(to, message);
}
```

이 구조는 새로운 채널이 생길 때마다 if 문을 추가해야 하고,
기존 코드를 수정하다 장애가 날 가능성도 높습니다.
이제 당신은 객체지향의 무기인 `다형성(polymorphism)`과 **추상 클래스**를 사용해 이 문제를 해결하려고 합니다.

---

## 🎯 미션 목표

* `.send(to, message)` 단 한 줄로 모든 알림을 보낼 수 있어야 합니다.
* 새로운 알림 채널을 추가해도 기존 코드를 수정하지 않아야 합니다.
* 추상 클래스와 오버라이딩, 다형성 개념을 실제 코드로 익힙니다.

---

## 📝 미션 요구사항

* `AbstractNotifier`라는 **추상 클래스**를 정의합니다.
* 자식 클래스들은 이 클래스를 `extends`로 상속받아야 합니다.
* 자식 클래스들은 반드시 `send(to, message)` 메서드를 구현해야 합니다.
* 실제 전송은 하지 않고 `console.log()`만 사용합니다.
* 여러 알림 객체를 배열로 묶고, `for...of` 반복문으로 `.send()`를 실행합니다.

---

## ✅ 정답 코드 및 설명

### 1. 추상 클래스 정의

```js
class AbstractNotifier {
  constructor(sender) {
    if (this.constructor === AbstractNotifier) {
      throw new Error("AbstractNotifier는 직접 인스턴스화할 수 없습니다.");
    }
    this.sender = sender;
    this.log = [];
  }

  send(to, message) {
    throw new Error("send()는 자식 클래스에서 반드시 구현해야 합니다.");
  }
}
```

* 이 클래스는 알림 시스템의 **공통 설계도**입니다.
* `constructor` 내부에서 자기 자신을 인스턴스화하면 에러를 던져, **직접 사용하지 못하게 막습니다.**
* `send()`는 구현 없이 에러만 던집니다. 이 방식으로 **자식 클래스에 구현을 강제**합니다.

---

### 2. 이메일 알림 클래스

```js
class EmailNotifier extends AbstractNotifier {
  send(to, message) {
    console.log(`[이메일] ${this.sender}@company.com → ${to}@email.com`);
    console.log(`내용: ${message}`);
    this.log.push({ to, message, method: "email", time: new Date().toISOString() });
  }
}
```

* `send()`를 오버라이드하여 이메일 형식으로 메시지를 출력합니다.
* `this.log.push()`를 통해 전송 기록을 남깁니다.

---

### 3. SMS 알림 클래스

```js
class SMSNotifier extends AbstractNotifier {
  send(to, message) {
    console.log(`[문자] ${this.sender} → ${to}`);
    console.log(`내용: ${message}`);
    this.log.push({ to, message, method: "sms", time: new Date().toISOString() });
  }
}
```

* 문자 형식으로 출력되는 `send()` 메서드를 구현합니다.
* 역시 전송 로그를 기록합니다.

---

### 4. 앱 푸시 알림 클래스

```js
class PushNotifier extends AbstractNotifier {
  constructor(sender, appName) {
    super(sender);
    this.appName = appName;
  }

  send(to, message) {
    console.log(`[앱푸시 - ${this.appName}] 수신자: ${to}`);
    console.log(`메시지: ${message}`);
    this.log.push({ to, message, method: "push", time: new Date().toISOString() });
  }
}
```

* `PushNotifier`는 추가 정보인 `appName`을 생성자에서 추가로 받습니다.
* `super(sender)`로 부모 생성자를 먼저 호출한 뒤, `this.appName`을 저장합니다.
* 메시지 출력에 앱 이름이 포함됩니다.

---

### 5. 테스트 실행 흐름

```js
const notifiers = [
  new EmailNotifier("noreply"),
  new SMSNotifier("010-1234-5678"),
  new PushNotifier("알림봇", "ChatApp")
];

for (const n of notifiers) {
  n.send("yuna", "결제가 완료되었습니다!");
}
```

* 서로 다른 알림 채널 객체들을 **배열로 묶어** 하나씩 반복합니다.
* 이때 우리는 **알림 방식이 뭔지 전혀 몰라도**, `.send()` 한 줄로 알림을 보냅니다.
* 이것이 바로 **다형성**입니다. 동일한 인터페이스, 다른 동작.

---

## ✨ 예상 출력 예시

```js
[이메일] noreply@company.com → yuna@email.com
내용: 결제가 완료되었습니다!

[문자] 010-1234-5678 → yuna
내용: 결제가 완료되었습니다!

[앱푸시 - ChatApp] 수신자: yuna
메시지: 결제가 완료되었습니다!
```

---

## 🧱 구조 시각화

```js
EmailNotifier          SMSNotifier             PushNotifier
     │                     │                       │
     ▼                     ▼                       ▼
EmailNotifier.prototype  SMSNotifier.prototype  PushNotifier.prototype
             \\             |                  //
                  \\        |                //
                     AbstractNotifier.prototype
```

* 모든 자식 클래스는 `AbstractNotifier`를 상속합니다.
* 각 클래스는 `send()`를 오버라이드하여 자기 방식대로 메시지를 보냅니다.
* 외부에서는 오직 `.send()`만 알면 됩니다.

---

## 🧠 구조 요약

* `AbstractNotifier`는 알림 클래스들의 **공통 설계도**이며 직접 사용할 수 없습니다.
* 자식 클래스들은 반드시 `.send()`를 구현해야 동작합니다.
* 실제 구현은 각 클래스마다 다르지만, 호출 방식은 `.send()` 한 줄로 통일됩니다.
* 이 구조는 \*\*다형성(polymorphism)\*\*을 실현하며,
* 유지보수성, 확장성, 코드의 깔끔함 측면에서 매우 유리합니다.
* 이는 객체지향 설계의 핵심 원칙 중 하나인 \*\*OCP(개방-폐쇄 원칙)\*\*도 만족합니다.

---

