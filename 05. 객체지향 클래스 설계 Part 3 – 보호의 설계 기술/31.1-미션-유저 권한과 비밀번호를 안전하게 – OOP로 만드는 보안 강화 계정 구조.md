# 📦 유저 권한과 비밀번호를 안전하게 – OOP로 만드는 보안 강화 계정 구조 (캡슐화 + 역할 제어 확장)

---

## 🧭 미션 배경

당신은 SaaS(Software as a Service) 기반의 기업용 협업 플랫폼을 운영 중인 스타트업에서 백엔드 개발을 담당하고 있습니다.
현재 수천 명의 직원이 플랫폼에 가입되어 있으며, 고객사마다 관리자와 일반 사용자의 권한이 분리되어 있습니다.

최근 다음과 같은 보안 이슈가 반복적으로 발생하면서, 계정 시스템에 대한 구조적 리팩토링이 시급해졌습니다:

- 일반 사용자가 자신의 `role`을 `"admin"`으로 변경하려는 시도
- 콘솔 디버깅 중 `user.password`가 로그에 그대로 찍혀 유출된 사례
- 외부 모듈에서 `user.role = "root"` 같은 직접 변경 시도
- 계정 생성 후 `email`이나 `role` 값이 의도치 않게 수정되는 사고

기존 시스템은 모든 속성이 퍼블릭으로 노출되어 있어, 외부 접근을 막을 수 없는 상태입니다.
이제 더 이상 public 필드에 의존한 구조로는 보안과 무결성을 지킬 수 없습니다.

---

## 🎯 미션 목표

이제 우리는 다음 목표를 달성해야 합니다:

- **민감 정보를 #private 필드로 보호**
- **비밀번호는 외부에서 보이지 않도록 하고 검증 메서드만 제공**
- **이메일은 읽기 전용으로만 공개 (수정 불가)**
- **역할(role)은 외부에서 임의 변경이 불가능하고, 관리자만 변경 가능**
- **비밀번호 변경은 기존 비밀번호 확인 + 새로운 비밀번호 유효성 검사를 거쳐야 함**

---

## 📋 미션 요구사항

1. `UserAccount` 클래스를 생성하세요.
2. 생성자는 다음 세 정보를 입력받습니다:

   - `username` (공개 정보)
   - `email` (읽기 전용으로 제공)
   - `password` (비공개 정보)

3. 다음 속성은 `#private` 필드로 선언하고 외부 접근을 차단해야 합니다:

   - `#password`
   - `#role` (기본값: `"user"`)

4. 다음 메서드를 클래스에 정의하세요:

   - `checkPassword(inputPassword)`
   - `changePassword(currentPassword, newPassword)`
   - `getEmail()`
   - `getRole()`
   - `updateRole(newRole, requesterRole)`

모든 상태 변경은 조건을 통과해야만 수행되며, 실패 시 콘솔에 경고 메시지를 출력합니다.

---

## 🔤 사용 문법 요약

- `#` 키워드를 활용한 private field 선언
- getter 또는 검증 메서드를 통한 간접 접근
- 조건 검사를 통한 안전한 상태 변경
- 콘솔 메시지를 통한 결과 피드백

---

## 📚 이 미션을 통해 배우는 것

- **객체 내부 정보 은닉의 필요성과 구현 방법**
- **getter / 검증 메서드의 차이점과 활용 방식**
- **역할 기반 접근 제어 구조 설계**
- **실무에서 자주 사용하는 계정 보호 패턴**

---

## ✅ 정답 코드

```js
class UserAccount {
  #password;
  #role;

  constructor(username, email, password) {
    this.username = username; // 공개 속성
    this.email = email; // 읽기 전용 getter로만 제공
    this.#password = password; // 외부 접근 불가
    this.#role = "user"; // 기본값: 일반 사용자
  }

  checkPassword(inputPassword) {
    return this.#password === inputPassword;
  }

  changePassword(currentPassword, newPassword) {
    if (this.#password === currentPassword) {
      if (typeof newPassword === "string" && newPassword.length >= 4) {
        this.#password = newPassword;
        console.log("✅ 비밀번호가 성공적으로 변경되었습니다.");
      } else {
        console.log("❌ 비밀번호는 최소 4자리 이상의 문자열이어야 합니다.");
      }
    } else {
      console.log("❌ 기존 비밀번호가 올바르지 않습니다.");
    }
  }

  getEmail() {
    return this.email;
  }

  getRole() {
    return this.#role;
  }

  updateRole(newRole, requesterRole) {
    if (requesterRole === "admin") {
      this.#role = newRole;
      console.log(`✅ 역할이 '${newRole}'로 변경되었습니다.`);
    } else {
      console.log(
        "❌ 권한이 없습니다. 역할 변경은 관리자만 수행할 수 있습니다."
      );
    }
  }
}
```

---

## ✅ 정답 코드 상세 설명

### 🔧 생성자

```js
constructor(username, email, password) {
  this.username = username;
  this.email = email;
  this.#password = password;
  this.#role = "user";
}
```

- `username`, `email`은 공개 속성이며 외부에서 접근 가능
- `#password`, `#role`은 `#`을 붙여 비공개 필드로 선언
- `#role`은 초기화 시 자동으로 `"user"`로 설정

---

### 🔐 checkPassword(inputPassword)

```js
checkPassword(inputPassword) {
  return this.#password === inputPassword;
}
```

- 외부에서는 비밀번호 자체를 볼 수 없고, 일치 여부만 확인 가능
- 반환값은 `true` 또는 `false`

---

### 🔁 changePassword(currentPassword, newPassword)

```js
changePassword(currentPassword, newPassword) {
  if (this.#password === currentPassword) {
    if (typeof newPassword === 'string' && newPassword.length >= 4) {
      this.#password = newPassword;
      console.log("✅ 비밀번호가 성공적으로 변경되었습니다.");
    } else {
      console.log("❌ 비밀번호는 최소 4자리 이상의 문자열이어야 합니다.");
    }
  } else {
    console.log("❌ 기존 비밀번호가 올바르지 않습니다.");
  }
}
```

- 기존 비밀번호와 일치해야만 변경 허용
- 새 비밀번호는 문자열이며 4자 이상이어야 함
- 조건을 통과하지 못하면 콘솔에 경고 출력

---

### 📧 getEmail()

```js
getEmail() {
  return this.email;
}
```

- 이메일을 읽을 수만 있으며, 수정은 불가

---

### 🧾 getRole()

```js
getRole() {
  return this.#role;
}
```

- 역할 정보도 읽기 전용
- 외부에서 `#role` 접근은 문법상 오류 발생

---

### 🧭 updateRole(newRole, requesterRole)

```js
updateRole(newRole, requesterRole) {
  if (requesterRole === "admin") {
    this.#role = newRole;
    console.log(`✅ 역할이 '${newRole}'로 변경되었습니다.`);
  } else {
    console.log("❌ 권한이 없습니다. 역할 변경은 관리자만 수행할 수 있습니다.");
  }
}
```

- 관리자만 역할 변경 가능
- 일반 사용자가 변경 시도 시 거부됨

---

## 🧪 테스트 흐름

```js
const user = new UserAccount("jiyoon", "jiyoon@email.com", "1234");

console.log(user.username); // jiyoon
console.log(user.getEmail()); // jiyoon@email.com
console.log(user.getRole()); // user

console.log(user.checkPassword("wrong")); // false
console.log(user.checkPassword("1234")); // true

user.changePassword("wrong", "abcd"); // ❌ 기존 비밀번호 틀림
user.changePassword("1234", "ab"); // ❌ 조건 미달
user.changePassword("1234", "5678"); // ✅ 성공

console.log(user.checkPassword("5678")); // true

user.updateRole("admin", "user"); // ❌ 권한 없음
user.updateRole("admin", "admin"); // ✅ 성공
console.log(user.getRole()); // admin
```

---

## 💻 예상 출력 결과

```js
jiyoon
jiyoon@email.com
user
false
true
❌ 기존 비밀번호가 올바르지 않습니다.
❌ 비밀번호는 최소 4자리 이상의 문자열이어야 합니다.
✅ 비밀번호가 성공적으로 변경되었습니다.
true
❌ 권한이 없습니다. 역할 변경은 관리자만 수행할 수 있습니다.
✅ 역할이 'admin'로 변경되었습니다.
admin
```

---

## 🧱 구조 시각화

```js
[UserAccount 인스턴스]
 ├─ username: 공개 정보
 ├─ email: 읽기 전용
 ├─ #password: 외부 접근 불가
 ├─ #role: 외부 접근 불가
 ├─ checkPassword(input): boolean 반환
 ├─ changePassword(current, new): 조건 만족 시만 변경
 ├─ getEmail(): 이메일 반환
 ├─ getRole(): 역할 반환
 └─ updateRole(newRole, requesterRole): 관리자만 변경 가능
```

---

## 🧠 구조 요약

| 설계 원칙          | 적용 방식                                                  |
| ------------------ | ---------------------------------------------------------- |
| **캡슐화**         | `#password`, `#role`을 private으로 선언하여 외부 접근 차단 |
| **정보 은닉**      | 민감 정보는 getter 또는 검증 메서드를 통해서만 간접 접근   |
| **권한 제어**      | 역할 변경은 `requesterRole === 'admin'`일 때만 허용        |
| **단일 책임 원칙** | 메서드들이 각각 하나의 책임만 갖도록 분리 (SRP 적용)       |

---
