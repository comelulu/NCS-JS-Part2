# 📦 제대로 설계하는 사용자 시스템: 클래스가 책임지는 고유 ID와 로그인 구조

---

## 🧭 미션 배경

당신은 이메일 회원가입 기반의 SaaS 서비스를 운영하는 스타트업의 개발자입니다.
서비스가 성장하면서 사용자 계정 관리에 여러 문제가 발생하고 있습니다:

- 사용자마다 고유한 ID가 없어 배열 순서만으로 데이터를 구분하다가 정보가 덮어씌워지는 문제
- 전체 가입자 수를 확인하려면 매번 DB 쿼리를 수동으로 실행해야 하는 비효율
- 이메일과 비밀번호로 로그인할 때마다 배열을 돌며 수동 비교하는 코드가 복붙되고 있음
- 비밀번호를 하드코딩하거나 외부에서 role을 직접 바꾸는 보안 사고

이제는 객체가 자신의 정보는 보호하고, 시스템 전체적인 흐름(총 가입자 수, 로그인 등)은 클래스가 책임지는
구조적인 객체지향 설계가 필요합니다.

---

## 🎯 미션 목표

- 각 사용자에게 **고유 ID**를 자동으로 부여합니다 (클래스 static 필드 활용).
- 전체 사용자 수와 사용자 목록은 클래스가 직접 추적하고 반환할 수 있어야 합니다.
- \*\*비밀번호, 역할, ID는 외부에서 접근할 수 없도록 캡슐화(#private)\*\*합니다.
- **로그인은 객체 없이도 `UserAccount.login(email, password)` 형태로 수행**됩니다.
- **역할 변경은 관리자 요청 시에만 가능**하도록 제한합니다.

---

## 📋 미션 요구사항

- `UserAccount` 클래스를 정의하세요.
- 다음 필드는 `#private`으로 선언해야 합니다:

  - `#id`, `#password`, `#role`

- 다음 클래스 속성은 `static`으로 정의해야 합니다:

  - `#nextId`, `#totalCount`, `#users`

- 다음 메서드를 포함해야 합니다:

  - `getEmail()`, `getRole()`, `getId()`
  - `checkPassword()`, `changePassword()`, `updateRole()`
  - `static login(email, password)`, `static getTotalUsers()`

---

## ✅ 정답 코드

```js
class UserAccount {
  // 클래스 전체에서 공유되는 private 정적 필드들
  static #nextId = 1;
  static #totalCount = 0;
  static #users = [];

  // 인스턴스 전용 private 필드들
  #id;
  #password;
  #role;

  constructor(username, email, password) {
    this.username = username;
    this.email = email;
    this.createdAt = new Date();

    this.#password = password;
    this.#role = "user";
    this.#id = UserAccount.#nextId++;

    UserAccount.#totalCount++;
    UserAccount.#users.push(this);
  }

  getEmail() {
    return this.email;
  }

  getRole() {
    return this.#role;
  }

  getId() {
    return this.#id;
  }

  checkPassword(inputPassword) {
    return this.#password === inputPassword;
  }

  changePassword(currentPassword, newPassword) {
    if (this.#password === currentPassword) {
      if (typeof newPassword === "string" && newPassword.length >= 4) {
        this.#password = newPassword;
        console.log("✅ 비밀번호가 성공적으로 변경되었습니다.");
      } else {
        console.log("❌ 비밀번호는 최소 4자리 이상의 문자열이어야 합니다.");
      }
    } else {
      console.log("❌ 기존 비밀번호가 올바르지 않습니다.");
    }
  }

  updateRole(newRole, requesterRole) {
    if (requesterRole === "admin") {
      this.#role = newRole;
      console.log(`✅ 역할이 '${newRole}'로 변경되었습니다.`);
    } else {
      console.log(
        "❌ 권한이 없습니다. 역할 변경은 관리자만 수행할 수 있습니다."
      );
    }
  }

  static getTotalUsers() {
    return `현재 가입자 수: ${UserAccount.#totalCount}명`;
  }

  static login(email, password) {
    const user = UserAccount.#users.find((u) => u.email === email);
    if (!user) {
      console.log("❌ 사용자 이메일을 찾을 수 없습니다.");
      return null;
    }
    if (!user.checkPassword(password)) {
      console.log("❌ 비밀번호가 올바르지 않습니다.");
      return null;
    }
    console.log(`✅ ${user.username}님 로그인 성공`);
    return user;
  }
}
```

---

## ✅ 정답 코드 상세 설명

### 🔧 생성자

```js
constructor(username, email, password);
```

- 사용자의 `username`, `email`, `password`를 받아 초기화
- `createdAt`은 생성 시각 자동 기록
- `#id`는 클래스 내부 `#nextId` 값을 사용해 자동 증가
- 생성된 인스턴스는 클래스의 `#users` 배열에 저장되고, `#totalCount`가 증가함

---

### 🆔 getId()

```js
getId() {
  return this.#id;
}
```

- 사용자 객체의 고유 ID를 외부에서 읽을 수 있도록 메서드 제공
- ID는 `#`으로 보호되어 직접 접근은 불가

---

### 🔐 checkPassword()

```js
checkPassword(inputPassword) {
  return this.#password === inputPassword;
}
```

- 외부에서 비밀번호 확인은 가능하지만 실제 값을 노출하지 않음

---

### 🔁 changePassword()

```js
changePassword(currentPassword, newPassword);
```

- 현재 비밀번호가 정확히 일치하고, 새 비밀번호가 4자 이상일 때만 변경
- 조건 미달일 경우 콘솔에 오류 메시지 출력

---

### 🧾 getRole()

```js
getRole() {
  return this.#role;
}
```

- 사용자의 현재 역할을 읽기 전용으로 반환

---

### 🧭 updateRole()

```js
updateRole(newRole, requesterRole);
```

- `requesterRole === 'admin'`인 경우에만 역할 변경 허용
- 일반 사용자가 role을 변경할 수 없도록 제어

---

### 📧 getEmail()

```js
getEmail() {
  return this.email;
}
```

- 이메일은 공개 정보지만 변경은 불가 (setter 없음)

---

### 🧮 static getTotalUsers()

```js
static getTotalUsers() {
  return `현재 가입자 수: ${UserAccount.#totalCount}명`;
}
```

- 현재 가입자 수를 클래스 단위에서 반환
- 관리자 대시보드 등에서 통계 출력에 유용

---

### 🔐 static login()

```js
static login(email, password)
```

- 사용자 인스턴스 없이 클래스 이름으로 로그인 가능
- `email`로 사용자 검색 후, `checkPassword()`로 인증
- 성공 시 사용자 객체 반환, 실패 시 `null` 반환

---

## 🧪 테스트 흐름

```js
const a = new UserAccount("철수", "chulsoo@email.com", "pass1234");
const b = new UserAccount("영희", "younghee@email.com", "abcd1234");

console.log(a.username); // 철수
console.log(a.getEmail()); // chulsoo@email.com
console.log(a.getRole()); // user
console.log(UserAccount.getTotalUsers()); // 현재 가입자 수: 2명

UserAccount.login("wrong@email.com", "1234"); // ❌ 이메일 없음
UserAccount.login("chulsoo@email.com", "wrong"); // ❌ 비밀번호 오류
UserAccount.login("chulsoo@email.com", "pass1234"); // ✅ 로그인 성공

a.changePassword("pass1234", "12"); // ❌ 짧은 비밀번호
a.changePassword("pass1234", "newpass"); // ✅ 변경 성공

a.updateRole("admin", "user"); // ❌ 권한 없음
a.updateRole("admin", "admin"); // ✅ 역할 변경
console.log(a.getRole()); // admin
```

---

## 🧱 구조 시각화

```js
[UserAccount 클래스]
 ├─ static #nextId         → 고유 ID 증가기
 ├─ static #totalCount     → 총 가입자 수
 ├─ static #users[]        → 사용자 목록
 ├─ static login()         → 로그인 메서드
 └─ static getTotalUsers() → 총 사용자 수 반환

[UserAccount 인스턴스]
 ├─ #id, #password, #role  → 비공개
 ├─ username, email        → 공개
 ├─ createdAt              → 가입 시각
 ├─ checkPassword()
 ├─ changePassword()
 ├─ getEmail(), getRole(), getId()
 └─ updateRole(newRole, requesterRole)
```

---

## 🧠 구조 요약

| 기능 구분      | 구현 방식                                                |
| -------------- | -------------------------------------------------------- |
| 고유 ID 생성   | `static #nextId`로 자동 증가                             |
| 전체 사용자 수 | `static #totalCount`, `getTotalUsers()`로 반환           |
| 로그인 기능    | `static login()`으로 클래스 차원 처리                    |
| 민감 정보 보호 | `#password`, `#role`, `#id`는 외부 접근 차단             |
| 역할 제어      | `updateRole()`은 `requesterRole === 'admin'`일 때만 허용 |
| 생성 시간 기록 | `createdAt` 필드 자동 저장                               |

---

## 📝 참고: 실무용 ID 설계 팁

이 예제에서는 학습 목적상 `#nextId`를 사용해 고유 ID를 자동 증가 방식으로 부여합니다.
하지만 실제 서비스에서는 다음과 같은 방식이 더욱 적합합니다:

- `crypto.randomUUID()` (Node.js 16.17 이상 내장)
- `uuid` 라이브러리 활용
- 데이터베이스에서 `AUTO_INCREMENT` 또는 `SERIAL` 필드 사용

이런 방식은 **충돌 없이 전역 고유 ID**를 안전하게 생성할 수 있어
분산 시스템이나 병렬 가입 환경에서도 안정성을 보장합니다.

---
