# 📦 새로운 택배사를 열고, 기존 코드는 닫아라 – 인터페이스 검증과 OCP 설계

---

## 🧭 미션 배경

지난 시간, 우리는 실행자(택배사) 객체가 서로 다르더라도 `ship(packageName)`이라는 공통 메서드만 갖고 있다면, 서비스 객체는 동일한 방식으로 실행자에게 기능을 위임할 수 있다는 것을 배웠습니다.

즉, 서비스는

> “난 이게 CJ인지, FedEx인지 몰라도 돼.
> ship()만 있으면 호출할게.”
> 라는 식으로 작동하죠.

이게 바로 `다형성(polymorphism)`의 힘입니다.

하지만 이번에는 실무에서 자주 마주치는 **두 가지 현실적인 문제**가 등장합니다:

### ❗ 문제 1: `ship()` 메서드가 빠진 잘못된 객체

```js
const BrokenCourier = {
  deliver(packageName) {
    console.log(`"${packageName}"을 배송합니다.`);
  },
};
```

이 객체에는 `ship()` 메서드가 없습니다.
그런데 서비스는 `deliveryCompany.ship(...)`으로 호출하죠. 결과는?

```
TypeError: deliveryCompany.ship is not a function
```

→ **시스템이 런타임에서 폭발합니다.**

이는 `"이 객체는 최소한의 약속도 지키지 않았다"`는 의미입니다.
즉, 객체 간의 `인터페이스(계약)`을 지키지 않은 것.

---

### ❗ 문제 2: 새로운 기능을 추가하려고 기존 코드를 수정

```js
function processDelivery(packageName) {
  if (useDHL) {
    DHLExpress.ship(packageName);
  } else {
    CJLogistics.ship(packageName);
  }
}
```

이렇게 되면 나중에 FedEx, UPS, 한진 등 택배사가 추가될 때마다
기존 코드를 계속 **수정**하게 됩니다.

→ 이는 객체지향 5원칙 중 하나인 **OCP(Open–Closed Principle)** 위반입니다.

> 기존 코드는 **닫혀 있어야(Closed)** 하고,
> 확장은 **열려 있어야(Open)** 합니다.

---

## ✅ 문제 해결 전략: 두 원칙의 동시 적용

1. **인터페이스 검증 (Interface Enforcement)**
   → 이 객체가 `ship()`이라는 메서드를 **진짜 갖고 있는지 검사**하자

2. **OCP 실현 (Open–Closed Principle)**
   → 기존 서비스 코드는 **절대 수정하지 않고**,
   새로운 택배사는 **밖에서 끼워 넣자**

---

## 🧪 정답 코드

```js
// 1. 택배사 객체 정의
const CJLogistics = {
  ship(packageName) {
    console.log(`📦 [CJ대한통운] "${packageName}" 배송을 시작합니다.`);
  },
};

const FedExKorea = {
  ship(packageName) {
    console.log(`✈️ [FedEx Korea] "${packageName}" 해외배송 시작`);
  },
};

const BrokenCourier = {
  deliver(packageName) {
    console.log(`🚫 "${packageName}"을 잘못된 방식으로 배송 시도 중입니다.`);
  },
};

// 2. 인터페이스 검증 함수
function validateDeliveryCompany(obj) {
  if (!obj || typeof obj.ship !== "function") {
    throw new Error(
      "❌ 택배사 객체는 반드시 ship(packageName) 메서드를 포함해야 합니다."
    );
  }
}

// 3. 물류 서비스 생성 함수
function createLogisticsService(deliveryCompany) {
  validateDeliveryCompany(deliveryCompany);

  return {
    processDelivery(packageName) {
      console.log(`[LogisticsService] "${packageName}" 배송 준비 중...`);
      deliveryCompany.ship(packageName);
    },
  };
}

// 4. 컨트롤러 생성 함수
function createLogisticsController(service) {
  return {
    send(packageName) {
      console.log(
        `[Controller] "${packageName}" 요청을 물류팀으로 전달합니다.`
      );
      service.processDelivery(packageName);
    },
  };
}

// 5. 앱 생성 함수
function createDeliveryApp(controller, customerName) {
  return {
    customerName,
    requestDelivery(packageName) {
      console.log(
        `${this.customerName}님이 "${packageName}" 배송을 요청했습니다.`
      );
      controller.send(packageName);
    },
  };
}

// 6. 실행 예시 – 정상
const fedexService = createLogisticsService(FedExKorea);
const fedexController = createLogisticsController(fedexService);
const fedexApp = createDeliveryApp(fedexController, "민지");

fedexApp.requestDelivery("전자책 리더기");

// 7. 실행 예시 – 실패
try {
  const brokenService = createLogisticsService(BrokenCourier);
} catch (error) {
  console.log(error.message);
}
```

## ✅ 정답 코드 상세 설명

```js
// 1. 택배사 객체 정의
const CJLogistics = {
  ship(packageName) {
    console.log(`📦 [CJ대한통운] "${packageName}" 배송을 시작합니다.`);
  },
};

const FedExKorea = {
  ship(packageName) {
    console.log(`✈️ [FedEx Korea] "${packageName}" 해외배송 시작`);
  },
};

const BrokenCourier = {
  deliver(packageName) {
    console.log(`🚫 "${packageName}"을 잘못된 방식으로 배송 시도 중입니다.`);
  },
};
```

### ✅ 상세 설명

- `CJLogistics`와 `FedExKorea`는 둘 다 `ship()`이라는 메서드를 제공합니다. 이것이 바로 서비스 객체가 기대하는 "인터페이스"입니다.
- 반면 `BrokenCourier`는 `deliver()`라는 이름을 사용하고 있어, 서비스에서 호출 시 오류가 발생하게 됩니다.
- 이처럼 다형성을 성립시키려면 **인터페이스 일관성**이 필수입니다.

---

```js
// 2. 인터페이스 검증 함수
function validateDeliveryCompany(obj) {
  if (!obj || typeof obj.ship !== "function") {
    throw new Error(
      "❌ 택배사 객체는 반드시 ship(packageName) 메서드를 포함해야 합니다."
    );
  }
}
```

### ✅ 상세 설명

- 이 함수는 **실행 객체가 올바른 인터페이스를 따르고 있는지** 검사합니다.
- 객체가 없거나 `ship`이라는 프로퍼티가 없거나, 그것이 함수가 아니라면 즉시 에러를 발생시켜 시스템을 **실행 전에 방어**합니다.
- 자바스크립트는 타입 검사가 없기 때문에 이런 **런타임 수동 검증**이 필요합니다.

---

```js
// 3. 물류 서비스 생성 함수
function createLogisticsService(deliveryCompany) {
  validateDeliveryCompany(deliveryCompany);

  return {
    processDelivery(packageName) {
      console.log(`[LogisticsService] "${packageName}" 배송 준비 중...`);
      deliveryCompany.ship(packageName);
    },
  };
}
```

### ✅ 상세 설명

- `createLogisticsService`는 **실행 객체를 인자로 받아 내부에 저장**하고, 실제 배송 로직을 `processDelivery`라는 메서드로 제공합니다.
- 시작 시 `validateDeliveryCompany()`로 인터페이스를 검사하여 ship이 없으면 실패합니다.
- 검증이 통과되면, 신뢰를 바탕으로 `deliveryCompany.ship(...)`을 실행합니다.

---

```js
// 4. 컨트롤러 생성 함수
function createLogisticsController(service) {
  return {
    send(packageName) {
      console.log(
        `[Controller] "${packageName}" 요청을 물류팀으로 전달합니다.`
      );
      service.processDelivery(packageName);
    },
  };
}
```

### ✅ 상세 설명

- `createLogisticsController`는 서비스 계층과 앱 계층을 중계하는 컨트롤러 역할입니다.
- 어떤 배송 요청이 들어오면 `service.processDelivery()`로 전달해 실행을 유도합니다.
- 책임이 명확히 분리되어, 나중에 로깅, 인증, 검증 등을 여기서 확장할 수 있습니다.

---

```js
// 5. 앱 생성 함수
function createDeliveryApp(controller, customerName) {
  return {
    customerName,
    requestDelivery(packageName) {
      console.log(
        `${this.customerName}님이 "${packageName}" 배송을 요청했습니다.`
      );
      controller.send(packageName);
    },
  };
}
```

### ✅ 상세 설명

- 이 객체는 사용자 입장에서 보이는 앱 계층을 구성합니다.
- 고객의 이름을 보관하며, 배송 요청이 들어오면 `controller.send()`를 호출합니다.
- 내부 구현에 대해 알 필요 없이, **ship()만 있으면 전체 흐름이 정상 동작**합니다.

---

```js
// 6. 실행 예시 – 정상
const fedexService = createLogisticsService(FedExKorea);
const fedexController = createLogisticsController(fedexService);
const fedexApp = createDeliveryApp(fedexController, "민지");

fedexApp.requestDelivery("전자책 리더기");
```

### ✅ 상세 설명

- `FedExKorea` 객체는 `ship()` 메서드를 갖고 있으므로 검증 통과.
- 각 계층을 조립한 뒤 앱에서 배송 요청을 실행하면 전체 구조가 순차적으로 동작.
- **다형성과 인터페이스 검증이 모두 통과한 정상 시나리오**입니다.

---

```js
// 7. 실행 예시 – 실패
try {
  const brokenService = createLogisticsService(BrokenCourier);
} catch (error) {
  console.log(error.message);
}
```

### ✅ 상세 설명

- `BrokenCourier`는 `ship()` 메서드를 갖고 있지 않기 때문에 `validateDeliveryCompany()`에서 에러 발생.
- 이 구조 덕분에 시스템이 런타임 중 **터지기 전에 미리 방어**할 수 있습니다.
- 검증이 없다면 `undefined is not a function`으로 더 큰 문제로 이어질 수 있죠.

---

## 🧪 실행 결과 예시

```js
민지님이 "전자책 리더기" 배송을 요청했습니다.
[Controller] "전자책 리더기" 요청을 물류팀으로 전달합니다.
[LogisticsService] "전자책 리더기" 배송 준비 중...
✈️ [FedEx Korea] "전자책 리더기" 해외배송 시작

❌ 택배사 객체는 반드시 ship(packageName) 메서드를 포함해야 합니다.
```

---

## 🧱 구조 시각화

```js
[DeliveryApp]
  └── requestDelivery()
        └── [Controller].send()
              └── [LogisticsService].processDelivery()
                    └── [택배사 객체].ship()

[createLogisticsService()]
  └── validateDeliveryCompany(obj)
        └── ship 메서드 있는지 확인 → 없으면 에러
```

---

## 🧠 구조 정리 – 핵심 요점

### ✅ 인터페이스 검증

- 실행자 객체가 진짜 기능(ship)을 갖고 있는지 사전에 검사
- 시스템의 **신뢰성과 안정성**을 보장
- 계약 기반 협력 구조 실현

### ✅ OCP 실현

- 기존 로직은 **수정 없이** 그대로 둠
- 새로운 택배사 객체는 **밖에서 조립**
- 확장성 향상, 테스트 안전성 확보

---

## 🧾 결론 – 객체지향 원칙 실현 요약

| 원칙            | 실현 방식                                                                      |
| --------------- | ------------------------------------------------------------------------------ |
| 다형성          | 서로 다른 실행자(ship 객체)를 동일한 방식으로 호출                             |
| 인터페이스 검증 | 실행자 객체의 구조를 명시적으로 검사하여 신뢰 기반 설계 구축                   |
| OCP             | 기존 코드를 수정하지 않고 새로운 실행자를 외부에서 조립하는 구조로 확장성 확보 |

---

## 🗂 폴더 구조 제안 (실제 프로젝트용)

```js
📦 logistics-system/
├── 📄 app.js                  ← 앱 실행 진입점
├── 📄 controller.js           ← 컨트롤러 객체 정의
├── 📄 service.js              ← 물류 서비스 객체 정의 (+ 인터페이스 검증)
├── 📄 couriers.js             ← 다양한 택배사 객체 정의
└── 📄 interface-check.js      ← 인터페이스 검증 유틸 함수 정의
```

---
