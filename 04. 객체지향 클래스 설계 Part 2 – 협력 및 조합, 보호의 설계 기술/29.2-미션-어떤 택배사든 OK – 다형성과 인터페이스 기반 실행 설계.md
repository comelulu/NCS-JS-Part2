# 📦 “어떤 택배사든 OK – 다형성과 인터페이스 기반 실행 설계”

---

## 🧭 미션 배경

지금까지 우리는 객체의 역할을 명확히 나누어,

- 앱은 **요청**만 받고,
- 컨트롤러는 **중계**만 하며,
- 물류 서비스는 **실제 처리**,
- 택배사는 **배송 실행**을 맡는 구조를 구현해왔습니다.

하지만 프로젝트가 커지면서 새로운 요구가 생겼습니다:

> “이번 고객은 해외배송이라 CJ 말고 **FedEx**를 써야 해요.”
> “VIP는 **롯데택배**만 원해요.”
> “G마켓 전용 이벤트에는 특정 전용 택배사를 써야 합니다!”

이처럼 **상황에 따라 배송 실행자가 달라지는 것**은 흔한 일입니다.
그렇다면 **물류 서비스는 택배사가 누구든 상관없이,
그냥 `ship()`만 호출하면 되는 구조**가 되어야 하겠죠?

이처럼 객체의 구체적인 종류에 상관없이 **동일한 방식으로 다룰 수 있게 해주는 설계 원칙**,
그게 바로 \*\*객체지향의 핵심인 다형성(polymorphism)\*\*입니다.

---

## 🎯 미션 목표

이번 미션에서는 다음을 구현합니다:

- 물류 서비스는 **택배사 객체가 누구인지 몰라도 `ship()`만 호출하면 OK**
- 어떤 택배사든 `ship(packageName)` 메서드를 **반드시 제공**
- 물류 서비스는 이 메서드만 믿고 **동일하게 호출**
- 이 구조를 통해 “동작은 동일하지만, 실행자는 유연하게 바뀌는” 구조를 구현

---

## 📋 미션 요구사항

- 다음 택배사 객체들을 정의합니다:

  - `CJLogistics`, `LotteCourier`, `FedExKorea`
  - 모두 `ship(packageName)` 메서드를 반드시 갖춰야 함

- `createLogisticsService(deliveryCompany)`는

  - **deliveryCompany가 누구든 `ship()`만 호출**하는 방식으로 구성

- 앱에서 `requestDelivery(packageName)`을 호출하면

  - 컨트롤러 → 서비스 → 택배사로 요청이 흐르고,
  - 마지막에는 해당 **택배사 객체의 `ship()` 메서드가 실행**

---

## 🔤 사용 문법 요약

- **다형성(polymorphism)**: 서로 다른 객체를 동일한 방식으로 다룸
- **인터페이스 규약**: `ship(packageName)`이라는 메서드 제공
- **팩토리 함수 패턴**: `createDeliveryApp(...)` 형태로 객체 구성

---

## 📚 이 미션을 통해 배우는 것

- 다양한 실행 객체를 하나의 **인터페이스**로 묶는 설계 원리
- \*\*다형성(polymorphism)\*\*이 실제로 어떻게 코드에 적용되는지 체험
- 실행 객체만 바꿔도 전체 시스템은 그대로 유지되는 유연한 설계
- 실무에서 결제 수단, 인증, 외부 API를 교체 가능하게 만드는 핵심 설계 철학

---

## ✨ 예상 출력 예시

```js
지현님이 "무선 키보드" 배송을 요청했습니다.
[Controller] "무선 키보드" 요청을 물류팀으로 중계합니다.
[LogisticsService] "무선 키보드" 배송 요청을 택배사로 전달합니다.
📦 [CJ대한통운] "무선 키보드" 배송이 시작되었습니다.

민지님이 "해외 전자책 리더기" 배송을 요청했습니다.
[Controller] "해외 전자책 리더기" 요청을 물류팀으로 중계합니다.
[LogisticsService] "해외 전자책 리더기" 배송 요청을 택배사로 전달합니다.
✈️ [FedEx Korea] "해외 전자책 리더기" 해외배송 진행 중입니다.

수빈님이 "블루투스 스피커" 배송을 요청했습니다.
[Controller] "블루투스 스피커" 요청을 물류팀으로 중계합니다.
[LogisticsService] "블루투스 스피커" 배송 요청을 택배사로 전달합니다.
🚚 [롯데택배] "블루투스 스피커"을 배송 중입니다.
```

---

## ✅ 정답 코드

```js
// 🚚 1. 다양한 택배사 객체 정의 – 인터페이스 규약: ship(packageName)
const CJLogistics = {
  ship(packageName) {
    console.log(`📦 [CJ대한통운] "${packageName}" 배송이 시작되었습니다.`);
  },
};

const LotteCourier = {
  ship(packageName) {
    console.log(`🚚 [롯데택배] "${packageName}"을 배송 중입니다.`);
  },
};

const FedExKorea = {
  ship(packageName) {
    console.log(`✈️ [FedEx Korea] "${packageName}" 해외배송 진행 중입니다.`);
  },
};

// 🏭 2. 물류 서비스 객체 – deliveryCompany에 ship() 호출
function createLogisticsService(deliveryCompany) {
  return {
    processDelivery(packageName) {
      console.log(
        `[LogisticsService] "${packageName}" 배송 요청을 택배사로 전달합니다.`
      );
      deliveryCompany.ship(packageName); // 다형성 기반 실행
    },
  };
}

// 🧭 3. 컨트롤러 객체 – 요청을 물류 서비스로 위임
function createLogisticsController(service) {
  return {
    send(packageName) {
      console.log(
        `[Controller] "${packageName}" 요청을 물류팀으로 중계합니다.`
      );
      service.processDelivery(packageName);
    },
  };
}

// 📱 4. 앱 객체 – 고객 요청을 컨트롤러에 위임
function createDeliveryApp(controller, customerName) {
  return {
    customerName,
    requestDelivery(packageName) {
      console.log(
        `${this.customerName}님이 "${packageName}" 배송을 요청했습니다.`
      );
      controller.send(packageName);
    },
  };
}

// 🧩 5. 시스템 조립 및 실행

// 앱 1: CJ대한통운 연결
const cjService = createLogisticsService(CJLogistics);
const cjController = createLogisticsController(cjService);
const cjApp = createDeliveryApp(cjController, "지현");
cjApp.requestDelivery("무선 키보드");

// 앱 2: FedEx 연결
const fedexService = createLogisticsService(FedExKorea);
const fedexController = createLogisticsController(fedexService);
const fedexApp = createDeliveryApp(fedexController, "민지");
fedexApp.requestDelivery("해외 전자책 리더기");

// 앱 3: 롯데택배 연결
const lotteService = createLogisticsService(LotteCourier);
const lotteController = createLogisticsController(lotteService);
const lotteApp = createDeliveryApp(lotteController, "수빈");
lotteApp.requestDelivery("블루투스 스피커");
```

## ✅ 정답 코드 및 상세 설명

### 1. 🚚 다양한 택배사 객체 정의 (인터페이스 규약 준수)

```js
const CJLogistics = {
  ship(packageName) {
    console.log(`📦 [CJ대한통운] "${packageName}" 배송이 시작되었습니다.`);
  },
};

const LotteCourier = {
  ship(packageName) {
    console.log(`🚚 [롯데택배] "${packageName}"을 배송 중입니다.`);
  },
};

const FedExKorea = {
  ship(packageName) {
    console.log(`✈️ [FedEx Korea] "${packageName}" 해외배송 진행 중입니다.`);
  },
};
```

🔍 **설명**

- 이 세 객체는 각각 독립적인 택배사입니다.
- 그러나 공통적으로 `ship(packageName)`이라는 메서드를 갖고 있어 **공통 인터페이스를 만족**합니다.
- 내부 구현은 서로 다르지만, 호출 방식은 동일하게 만들었기 때문에 물류 서비스는 **누구든 동일한 방식으로 다룰 수 있습니다.**

---

### 2. 🏭 물류 서비스 – 실행 객체에 ship() 호출

```js
function createLogisticsService(deliveryCompany) {
  return {
    processDelivery(packageName) {
      console.log(
        `[LogisticsService] "${packageName}" 배송 요청을 택배사로 전달합니다.`
      );
      deliveryCompany.ship(packageName);
    },
  };
}
```

🔍 **설명**

- `deliveryCompany`는 어떤 객체든 괜찮습니다. 단, **ship() 메서드만 있으면 됩니다.**
- 이 구조 덕분에 CJ든, 롯데든, FedEx든 모두 다 동일한 방식으로 실행할 수 있습니다.
- 즉, 이 함수는 **구현이 아닌 인터페이스만을 의존**하는 구조로, **완전한 다형성 기반 설계**를 실현합니다.

---

### 3. 🧭 컨트롤러 – 요청 중계자

```js
function createLogisticsController(service) {
  return {
    send(packageName) {
      console.log(
        `[Controller] "${packageName}" 요청을 물류팀으로 중계합니다.`
      );
      service.processDelivery(packageName);
    },
  };
}
```

🔍 **설명**

- 컨트롤러는 여전히 중계만 담당합니다.
- 어떤 서비스가 들어오든 `send()` 메서드로 전달하는 방식만 고정되어 있어, **구조가 매우 유연하고 안정적**입니다.

---

### 4. 📱 앱 – 사용자 인터페이스

```js
function createDeliveryApp(controller, customerName) {
  return {
    customerName,
    requestDelivery(packageName) {
      console.log(
        `${this.customerName}님이 "${packageName}" 배송을 요청했습니다.`
      );
      controller.send(packageName);
    },
  };
}
```

🔍 **설명**

- 앱은 가장 바깥 계층으로, 고객과 직접 맞닿아 있습니다.
- 내부 구현은 전혀 몰라도 되고, 단지 요청만 위임하면 됩니다.
- 이 객체 역시 단일 책임만 수행하므로 **유지보수가 매우 쉽고 역할이 명확**합니다.

---

## 🧩 시스템 조립 및 실행

```js
// CJ대한통운으로 연결된 앱
const cjService = createLogisticsService(CJLogistics);
const cjController = createLogisticsController(cjService);
const cjApp = createDeliveryApp(cjController, "지현");
cjApp.requestDelivery("무선 키보드");

// FedEx로 연결된 앱
const fedexService = createLogisticsService(FedExKorea);
const fedexController = createLogisticsController(fedexService);
const fedexApp = createDeliveryApp(fedexController, "민지");
fedexApp.requestDelivery("해외 전자책 리더기");

// 롯데로 연결된 앱
const lotteService = createLogisticsService(LotteCourier);
const lotteController = createLogisticsController(lotteService);
const lotteApp = createDeliveryApp(lotteController, "수빈");
lotteApp.requestDelivery("블루투스 스피커");
```

---

## ✅ 출력 결과

```js
지현님이 "무선 키보드" 배송을 요청했습니다.
[Controller] "무선 키보드" 요청을 물류팀으로 중계합니다.
[LogisticsService] "무선 키보드" 배송 요청을 택배사로 전달합니다.
📦 [CJ대한통운] "무선 키보드" 배송이 시작되었습니다.

민지님이 "해외 전자책 리더기" 배송을 요청했습니다.
[Controller] "해외 전자책 리더기" 요청을 물류팀으로 중계합니다.
[LogisticsService] "해외 전자책 리더기" 배송 요청을 택배사로 전달합니다.
✈️ [FedEx Korea] "해외 전자책 리더기" 해외배송 진행 중입니다.

수빈님이 "블루투스 스피커" 배송을 요청했습니다.
[Controller] "블루투스 스피커" 요청을 물류팀으로 중계합니다.
[LogisticsService] "블루투스 스피커" 배송 요청을 택배사로 전달합니다.
🚚 [롯데택배] "블루투스 스피커"을 배송 중입니다.
```

---

## 🧠 구조 시각화

```js
[DeliveryApp]
  └── requestDelivery()
        └── [Controller].send()
              └── [LogisticsService].processDelivery()
                    └── [택배사 객체].ship()

[택배사 객체들]
  ├── CJLogistics → ship()
  ├── LotteCourier → ship()
  └── FedExKorea → ship()
```

> 실행 객체가 누구든 **`ship()`만 제공하면 서비스는 걱정 없이 호출 가능**
> → 이게 바로 **다형성과 인터페이스 기반 설계의 핵심**

---

## 🧠 구조 요약

- ✅ **다형성(polymorphism)**: 서로 다른 객체를 같은 방식으로 처리
- ✅ **인터페이스 규약**: `ship(packageName)`이라는 동일한 메서드
- ✅ **유지보수성 증가**: 새로운 택배사 추가해도 서비스 코드 변경 없음
- ✅ **유연한 확장**: 실행자 교체, A/B 테스트, 조건 기반 전략에도 적합

---
